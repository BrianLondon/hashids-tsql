USE [HashidsTsql];
GO

﻿CREATE SCHEMA [hashids]
    AUTHORIZATION [dbo];
GO

﻿CREATE TYPE [hashids].[ListOfBigint] AS TABLE (
    [Id]    INT IDENTITY (1, 1) NOT NULL,
    [Value] BIGINT NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC));
﻿CREATE TYPE [hashids].[ListOfInt] AS TABLE (
    [Id]    INT IDENTITY (1, 1) NOT NULL,
    [Value] INT NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC));

﻿CREATE FUNCTION [hashids].[consistentShuffle]
(
	@alphabet nvarchar(255),
	@salt nvarchar(255)
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	
	-- Null or Whitespace?
	IF @salt IS NULL OR LEN(LTRIM(RTRIM(@salt))) = 0 BEGIN
		RETURN @alphabet;
	END

	DECLARE
		@ls int = LEN(@salt),
		@i int = LEN(@alphabet) - 1,
		@v int = 0,
		@p int = 0, 
		@n int = 0,
		@j int = 0,
		@temp nchar(1);

	WHILE @i > 0 BEGIN
		
		SET @v = @v % @ls;
		SET @n = UNICODE(SUBSTRING(@salt, @v + 1, 1));
		SET @p = @p + @n;
		SET @j = (@n + @v + @p) % @i;
		SET @temp = SUBSTRING(@alphabet, @j + 1, 1);
		SET @alphabet = 
				SUBSTRING(@alphabet, 1, @j) + 
				SUBSTRING(@alphabet, @i + 1, 1) + 
				SUBSTRING(@alphabet, @j + 2, 255);
		SET @alphabet = 
				SUBSTRING(@alphabet, 1, @i) + 
				@temp + 
				SUBSTRING(@alphabet, @i + 2, 255);
		SET @i = @i - 1;
		SET @v = @v + 1;

	END -- WHILE

	RETURN @alphabet;

END
GO

﻿CREATE FUNCTION [hashids].[hash]
(
	@input int,
	@alphabet nvarchar(255)
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	DECLARE
		@hash nvarchar(255) = N'',
		@alphabetLength int = LEN(@alphabet),
		@pos int;

	WHILE 1 = 1 BEGIN
		SET @pos = @input % @alphabetLength;
		SET @hash = SUBSTRING(@alphabet, @pos + 1, 1) + @hash;
		SET @input = CAST((@input / @alphabetLength) as int);
		IF @input <= 0
			BREAK;
	END

	RETURN @hash;
END
GO

﻿CREATE FUNCTION [hashids].[encode1]
(
	@number int
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	-- Options Data - generated by hashids-tsql
	DECLARE
		@salt nvarchar(255) = N'Mb4ey0LV54g5',
		@alphabet nvarchar(255) = N'ZO8EGXyoWNjLDVvb9Kdx2PeABnakm05JqzM4R3gwYp7r',
		@seps nvarchar(255) = N'HtcFfiTsUChuIS',
		@guards nvarchar(255) = N'6Q1l',
		@minHashLength int = 0;
		-- Input Alphabet: N'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

	-- Working Data
	DECLARE
		@numbersHashInt int,
		@lottery nchar(1),
		@buffer nvarchar(255),
		@last nvarchar(255),
		@ret nvarchar(255);

	SET @numbersHashInt = @number % 100;
	SET @lottery = SUBSTRING(@alphabet, (@numbersHashInt % LEN(@alphabet)) + 1, 1);
	SET @ret = @lottery;
	SET @buffer = @lottery + @salt + @alphabet;
	SET @alphabet = [hashids].[consistentShuffle](@alphabet, SUBSTRING(@buffer, 1, LEN(@alphabet)));
	SET @last = [hashids].[hash](@number, @alphabet);
	SET @ret = @ret + @last;
	----------------------------------------------------------------------------
	-- Enforce minHashLength
	----------------------------------------------------------------------------
	IF LEN(@ret) < @minHashLength BEGIN
		DECLARE
			@guardIndex int,
			@guard nchar(1),
			@halfLength int,
			@excess int;
		------------------------------------------------------------------------
		-- Add first 2 guard characters
		------------------------------------------------------------------------
		SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 1, 1))) % LEN(@guards);
		SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
		SET @ret = @guard + @ret;
		IF LEN(@ret) < @minHashLength BEGIN
			SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 3, 1))) % LEN(@guards);
			SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
			SET @ret = @ret + @guard;
		END
		------------------------------------------------------------------------
		-- Add the rest
		------------------------------------------------------------------------
		WHILE LEN(@ret) < @minHashLength BEGIN
			SET @halfLength = IsNull(@halfLength, CAST((LEN(@alphabet) / 2) as int));
			SET @alphabet = [hashids].[consistentShuffle](@alphabet, @alphabet);
			SET @ret = SUBSTRING(@alphabet, @halfLength + 1, 255) + @ret + 
					SUBSTRING(@alphabet, 1, @halfLength);
			SET @excess = LEN(@ret) - @minHashLength;
			IF @excess > 0 
				SET @ret = SUBSTRING(@ret, CAST((@excess / 2) as int) + 1, @minHashLength);
		END
	END
	RETURN @ret;
END
GO

﻿CREATE FUNCTION [hashids].[encode2]
(
	@number1 int,
	@number2 int
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	-- Options Data - generated by hashids-tsql
	DECLARE
		@salt nvarchar(255) = N'Mb4ey0LV54g5',
		@alphabet nvarchar(255) = N'ZO8EGXyoWNjLDVvb9Kdx2PeABnakm05JqzM4R3gwYp7r',
		@seps nvarchar(255) = N'HtcFfiTsUChuIS',
		@guards nvarchar(255) = N'6Q1l',
		@minHashLength int = 0;
		-- Input Alphabet: N'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

	-- Working Data
	DECLARE
		@numbersHashInt int,
		@lottery nchar(1),
		@buffer nvarchar(255),
		@last nvarchar(255),
		@ret nvarchar(255),
		@sepsIndex int;

	SET @numbersHashInt = (@number1 % 100) + (@number2 % 101);

	SET @lottery = SUBSTRING(@alphabet, (@numbersHashInt % LEN(@alphabet)) + 1, 1);
	SET @ret = @lottery;

	SET @buffer = @lottery + @salt + @alphabet;
	SET @alphabet = [hashids].[consistentShuffle](@alphabet, SUBSTRING(@buffer, 1, LEN(@alphabet)));
	SET @last = [hashids].[hash](@number1, @alphabet);
	SET @ret = @ret + @last;

	-- Before adding @number2, add a separator
	SET @sepsIndex = @number1 % UNICODE(SUBSTRING(@last, 1, 1));
	SET @sepsIndex = @sepsIndex % LEN(@seps);
	SET @ret = @ret + SUBSTRING(@seps, @sepsIndex + 1, 1);

	-- Add @number2
	SET @buffer = @lottery + @salt + @alphabet;
	SET @alphabet = [hashids].[consistentShuffle](@alphabet, SUBSTRING(@buffer, 1, LEN(@alphabet)));
	SET @last = [hashids].[hash](@number2, @alphabet);
	SET @ret = @ret + @last;

	----------------------------------------------------------------------------
	-- Enforce minHashLength
	----------------------------------------------------------------------------
	IF LEN(@ret) < @minHashLength BEGIN
		DECLARE
			@guardIndex int,
			@guard nchar(1),
			@halfLength int,
			@excess int;
		------------------------------------------------------------------------
		-- Add first 2 guard characters
		------------------------------------------------------------------------
		SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 1, 1))) % LEN(@guards);
		SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
		SET @ret = @guard + @ret;
		IF LEN(@ret) < @minHashLength BEGIN
			SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 3, 1))) % LEN(@guards);
			SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
			SET @ret = @ret + @guard;
		END
		------------------------------------------------------------------------
		-- Add the rest
		------------------------------------------------------------------------
		WHILE LEN(@ret) < @minHashLength BEGIN
			SET @halfLength = IsNull(@halfLength, CAST((LEN(@alphabet) / 2) as int));
			SET @alphabet = [hashids].[consistentShuffle](@alphabet, @alphabet);
			SET @ret = SUBSTRING(@alphabet, @halfLength + 1, 255) + @ret + 
					SUBSTRING(@alphabet, 1, @halfLength);
			SET @excess = LEN(@ret) - @minHashLength;
			IF @excess > 0 
				SET @ret = SUBSTRING(@ret, CAST((@excess / 2) as int) + 1, @minHashLength);
		END
	END
	RETURN @ret;
END
GO

﻿CREATE FUNCTION [hashids].[encodeList]
(
	@numbers [hashids].[ListOfInt] READONLY
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	-- Options Data - generated by hashids-tsql
	DECLARE
		@salt nvarchar(255) = N'Mb4ey0LV54g5',
		@alphabet nvarchar(255) = N'ZO8EGXyoWNjLDVvb9Kdx2PeABnakm05JqzM4R3gwYp7r',
		@seps nvarchar(255) = N'HtcFfiTsUChuIS',
		@guards nvarchar(255) = N'6Q1l',
		@minHashLength int = 0;
		-- Input Alphabet: N'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

	-- Working Data
	DECLARE
		@numbersHashInt int = 0,
		@lottery nchar(1),
		@buffer nvarchar(255),
		@last nvarchar(255),
		@ret nvarchar(255),
		@sepsIndex int,
		@lastId int,
		@count int = IsNull((SELECT COUNT(*) FROM @numbers), 0),
		@i int = 0,
		@id int = 0,
		@number int;

	-- Calculate numbersHashInt
	SET @lastId = IsNull((SELECT MAX([Id]) FROM @numbers), 0)
	WHILE @id < @lastId BEGIN
		SELECT TOP 1 @id = [Id], @number = [Value] FROM @numbers WHERE [Id] > @id
		SET @numbersHashInt += (@number % (@i + 100));
		SET @i += 1
	END
	
	-- Choose lottery
	SET @lottery = SUBSTRING(@alphabet, (@numbersHashInt % LEN(@alphabet)) + 1, 1);
	SET @ret = @lottery;

	-- Encode many
	SET @i = 0
	SET @id = 0
	WHILE @id < @lastId BEGIN
		SELECT TOP 1 @id = [Id], @number = [Value] FROM @numbers WHERE [Id] > @id

		SET @buffer = @lottery + @salt + @alphabet;
		SET @alphabet = [hashids].[consistentShuffle](@alphabet, SUBSTRING(@buffer, 1, LEN(@alphabet)));
		SET @last = [hashids].[hash](@number, @alphabet);
		SET @ret = @ret + @last;

		IF (@i + 1) < @count BEGIN
			SET @sepsIndex = @number % (UNICODE(SUBSTRING(@last, 1, 1)) + @i);
			SET @sepsIndex = @sepsIndex % LEN(@seps);
			SET @ret = @ret + SUBSTRING(@seps, @sepsIndex + 1, 1);
		END

		SET @i += 1
	END

	----------------------------------------------------------------------------
	-- Enforce minHashLength
	----------------------------------------------------------------------------
	IF LEN(@ret) < @minHashLength BEGIN
		DECLARE
			@guardIndex int,
			@guard nchar(1),
			@halfLength int,
			@excess int;
		------------------------------------------------------------------------
		-- Add first 2 guard characters
		------------------------------------------------------------------------
		SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 1, 1))) % LEN(@guards);
		SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
		SET @ret = @guard + @ret;
		IF LEN(@ret) < @minHashLength BEGIN
			SET @guardIndex = (@numbersHashInt + UNICODE(SUBSTRING(@ret, 3, 1))) % LEN(@guards);
			SET @guard = SUBSTRING(@guards, @guardIndex + 1, 1);
			SET @ret = @ret + @guard;
		END
		------------------------------------------------------------------------
		-- Add the rest
		------------------------------------------------------------------------
		WHILE LEN(@ret) < @minHashLength BEGIN
			SET @halfLength = IsNull(@halfLength, CAST((LEN(@alphabet) / 2) as int));
			SET @alphabet = [hashids].[consistentShuffle](@alphabet, @alphabet);
			SET @ret = SUBSTRING(@alphabet, @halfLength + 1, 255) + @ret + 
					SUBSTRING(@alphabet, 1, @halfLength);
			SET @excess = LEN(@ret) - @minHashLength;
			IF @excess > 0 
				SET @ret = SUBSTRING(@ret, CAST((@excess / 2) as int) + 1, @minHashLength);
		END
	END
	RETURN @ret;
END﻿CREATE FUNCTION [hashids].[encodeSplit] (
	@input nvarchar(max),
	@delim nvarchar(128) = NULL
)
RETURNS nvarchar(255)
WITH SCHEMABINDING
AS
BEGIN
	SET @delim = IsNull(@delim, N',');

	DECLARE
		@list as [hashids].[ListOfInt]
	DECLARE
		@item nvarchar(4000),
		@itemList nvarchar(max),
		@delimIndex int

	SET @itemList = @input
	SET @delimIndex = CHARINDEX(@delim, @itemList, 0)

	WHILE (@delimIndex != 0) BEGIN
		SET @item = SUBSTRING(@itemList, 0, @delimIndex)
		INSERT INTO @list([Value]) VALUES(CAST(@item as int))

		-- Set @itemList = @itemList minus one less item
		SET @itemList = SUBSTRING(@itemList, @delimIndex+1, LEN(@itemList)-@delimIndex)
		SET @delimIndex = CHARINDEX(@delim, @itemList, 0)
	END

	IF @item IS NOT NULL BEGIN -- At least one delimiter was encountered in @input
		SET @item = @itemList
		INSERT INTO @list([Value]) VALUES(CAST(@item as int))
	END ELSE BEGIN
		-- No delimiters were encountered in @input, so just return @input
		INSERT INTO @list([Value]) VALUES(CAST(@input as int))
	END

	RETURN [hashids].[encodeList](@list);
END